
grammar GDL

////////////////////////////////////////////////////////////////////////////////

inline token Digit         :: '[0-9]'
inline token Letter        :: '[a-zA-Z]'
inline token LetterOrDigit :: '[a-zA-Z0-9]'

skip token Whitespace :: '[ \t]+'
skip token Newline    :: '\n'
skip token Comment    :: '/\\*.*\\*/|//.*\n'

token StringToken     :: '\'(\\\\.|[^\'])*\'|"(\\\\.|[^"])*"'
token IdentifierToken :: '{Letter}({LetterOrDigit}|_)*'
token IntegerToken    :: '{Digit}+'

keyword IdentifierToken -> KeywordToken
symbol SymbolToken

////////////////////////////////////////////////////////////////////////////////

GDL :: 'grammar' (IdentifierToken as grammarName) ({GDLStatement *} as statements)

GDLStatement {
    GDLTokenStatement {
        GDLSymbolSpecifier       :: 'symbol' (IdentifierToken as symbolToken)
        GDLKeywordTransformer    :: 'keyword' (IdentifierToken as sourceToken) '->' (IdentifierToken as keywordToken)
        GDLTokenDefinition       :: ('skip' as? skip) 'token' (IdentifierToken as name) '::' (StringToken as regex)
        GDLInlineTokenDefinition :: 'inline' 'token' (IdentifierToken as name) '::' (StringToken as regex)
    }
    GDLRuleStatement {
        GDLRule            :: (IdentifierToken as name) ['<' {IdentifierToken as parameter ~ ','} '>'] '::' {GDLPattern as pattern *} Newline
        GDLAlternationRule :: (IdentifierToken as name) ['<' {IdentifierToken as parameter ~ ','} '>'] '{' {GDLAlternationRuleStatement as statement *} '}'
    }
}

GDLAlternationRuleStatement {
        GDLInfixLRule      :: 'infixl' (IntegerToken as precedence) (IdentifierToken as name) '::' {GDLPattern as pattern *} Newline
        GDLInfixRRule      :: 'infixr' (IntegerToken as precedence) (IdentifierToken as name) '::' {GDLPattern as pattern *} Newline
        GDLUnaryLRule      :: 'unaryl' (IntegerToken as precedence) (IdentifierToken as name) '::' {GDLPattern as pattern *} Newline
        GDLUnaryRRule      :: 'unaryr' (IntegerToken as precedence) (IdentifierToken as name) '::' {GDLPattern as pattern *} Newline
        GDLRule            :: (IdentifierToken as name) '::' {GDLPattern as pattern *} Newline
        GDLAlternationRule :: (IdentifierToken as name) '{' statements: {GDLAlternationRuleStatement *} '}'
}

GDLPattern {
    GDLLiteral       :: StringToken as value
    GDLRuleReference :: ('inline' as? inline) (IdentifierToken as reference) ['<' {GDLPattern as parameter ~ ','} '>'] ['as' ('?' as? q) (IdentifierToken as label)]
    GDLParen         :: '(' {GDLPattern as pattern *} ')'
    GDLSepBy         :: '{' {GDLPattern as pattern *} '~' ({GDLPattern *} as delimiter) ('?' as? zeroAccepted) '}'
    GDLMany0         :: '{' {GDLPattern as pattern *} '*' '}'
    GDLMany1         :: '{' {GDLPattern as pattern *} '+' '}'
    GDLOptional      :: '[' {GDLPattern as pattern *} ']'
}
